//! Generates Luau configuration files from the sync state (lock file).
//!
//! This module converts the `rbxsync-lock.yml` state into a Luau module
//! that can be used in-game to reference resource IDs and metadata.

use crate::state::SyncState;
use anyhow::Result;
use log::info;
use std::path::Path;

/// Generate a Luau configuration file from the sync state.
///
/// # Arguments
/// * `state` - The sync state containing resource IDs
/// * `universe_id` - The universe ID to include in the output
/// * `output_path` - Path where the output file will be written
pub fn generate_config(state: &SyncState, universe_id: u64, output_path: &str) -> Result<()> {
    let path = Path::new(output_path);
    let content = generate_luau_content(state, universe_id);

    // Create parent directories if they don't exist
    if let Some(parent) = path.parent() {
        if !parent.as_os_str().is_empty() {
            std::fs::create_dir_all(parent)?;
        }
    }

    std::fs::write(path, &content)?;
    info!("Generated config file: {}", output_path);

    Ok(())
}

/// Generate the Luau content string from state.
fn generate_luau_content(state: &SyncState, universe_id: u64) -> String {
    let mut output = String::new();

    // Header comment
    output.push_str("--!strict\n");
    output.push_str("-- Auto-generated by rbxsync. Do not edit manually.\n");
    output.push_str("-- This file is regenerated each time `rbxsync run` completes.\n\n");

    // Type definitions
    output.push_str("export type Universe = {\n");
    output.push_str("\tId: number,\n");
    output.push_str("\tName: string?,\n");
    output.push_str("\tDescription: string?,\n");
    output.push_str("\tGenre: string?,\n");
    output.push_str("\tPlayableDevices: {string}?,\n");
    output.push_str("\tMaxPlayers: number?,\n");
    output.push_str("\tPrivateServerCost: (number | \"disabled\")?,\n");
    output.push_str("}\n\n");

    output.push_str("export type GamePass = {\n");
    output.push_str("\tId: number,\n");
    output.push_str("\tName: string,\n");
    output.push_str("\tDescription: string?,\n");
    output.push_str("\tPrice: number?,\n");
    output.push_str("\tIsForSale: boolean?,\n");
    output.push_str("}\n\n");

    output.push_str("export type DeveloperProduct = {\n");
    output.push_str("\tId: number,\n");
    output.push_str("\tName: string,\n");
    output.push_str("\tDescription: string?,\n");
    output.push_str("\tPrice: number?,\n");
    output.push_str("}\n\n");

    output.push_str("export type Badge = {\n");
    output.push_str("\tId: number,\n");
    output.push_str("\tName: string,\n");
    output.push_str("\tDescription: string?,\n");
    output.push_str("\tIsEnabled: boolean?,\n");
    output.push_str("}\n\n");

    output.push_str("return {\n");

    // Universe
    output.push_str("\tUniverse = {\n");
    output.push_str(&format!("\t\tId = {},\n", universe_id));
    
    if let Some(ref universe) = state.universe {
        if let Some(ref name) = universe.name {
            output.push_str(&format!("\t\tName = \"{}\",\n", escape_luau_string(name)));
        }
        if let Some(ref description) = universe.description {
            output.push_str(&format!("\t\tDescription = \"{}\",\n", escape_luau_string(description)));
        }
        if let Some(ref genre) = universe.genre {
            output.push_str(&format!("\t\tGenre = \"{}\",\n", escape_luau_string(genre)));
        }
        if let Some(ref devices) = universe.playable_devices {
            let devices_str: Vec<String> = devices.iter()
                .map(|d| format!("\"{}\"", escape_luau_string(d)))
                .collect();
            output.push_str(&format!("\t\tPlayableDevices = {{ {} }},\n", devices_str.join(", ")));
        }
        if let Some(max_players) = universe.max_players {
            output.push_str(&format!("\t\tMaxPlayers = {},\n", max_players));
        }
        if let Some(ref cost) = universe.private_server_cost {
            if cost == "disabled" {
                output.push_str("\t\tPrivateServerCost = \"disabled\",\n");
            } else {
                output.push_str(&format!("\t\tPrivateServerCost = {},\n", cost));
            }
        }
    }
    output.push_str("\t} :: Universe,\n\n");

    // Game Passes
    output.push_str("\tGamePasses = {\n");
    let mut game_passes: Vec<_> = state.game_passes.iter().collect();
    game_passes.sort_by_key(|(id, _)| *id);
    for (id, resource) in game_passes {
        output.push_str("\t\t{\n");
        output.push_str(&format!("\t\t\tId = {},\n", id));
        output.push_str(&format!("\t\t\tName = \"{}\",\n", escape_luau_string(&resource.name)));
        if let Some(ref description) = resource.description {
            output.push_str(&format!("\t\t\tDescription = \"{}\",\n", escape_luau_string(description)));
        }
        if let Some(price) = resource.price {
            output.push_str(&format!("\t\t\tPrice = {},\n", price));
        }
        if let Some(is_for_sale) = resource.is_for_sale {
            output.push_str(&format!("\t\t\tIsForSale = {},\n", is_for_sale));
        }
        output.push_str("\t\t},\n");
    }
    output.push_str("\t} :: { GamePass },\n\n");

    // Developer Products
    output.push_str("\tDeveloperProducts = {\n");
    let mut products: Vec<_> = state.developer_products.iter().collect();
    products.sort_by_key(|(id, _)| *id);
    for (id, resource) in products {
        output.push_str("\t\t{\n");
        output.push_str(&format!("\t\t\tId = {},\n", id));
        output.push_str(&format!("\t\t\tName = \"{}\",\n", escape_luau_string(&resource.name)));
        if let Some(ref description) = resource.description {
            output.push_str(&format!("\t\t\tDescription = \"{}\",\n", escape_luau_string(description)));
        }
        if let Some(price) = resource.price {
            output.push_str(&format!("\t\t\tPrice = {},\n", price));
        }
        output.push_str("\t\t},\n");
    }
    output.push_str("\t} :: { DeveloperProduct },\n\n");

    // Badges
    output.push_str("\tBadges = {\n");
    let mut badges: Vec<_> = state.badges.iter().collect();
    badges.sort_by_key(|(id, _)| *id);
    for (id, resource) in badges {
        output.push_str("\t\t{\n");
        output.push_str(&format!("\t\t\tId = {},\n", id));
        output.push_str(&format!("\t\t\tName = \"{}\",\n", escape_luau_string(&resource.name)));
        if let Some(ref description) = resource.description {
            output.push_str(&format!("\t\t\tDescription = \"{}\",\n", escape_luau_string(description)));
        }
        if let Some(is_enabled) = resource.is_enabled {
            output.push_str(&format!("\t\t\tIsEnabled = {},\n", is_enabled));
        }
        output.push_str("\t\t},\n");
    }
    output.push_str("\t} :: { Badge },\n");

    output.push_str("}\n");

    output
}

/// Escape special characters in a Luau string.
fn escape_luau_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::state::{ResourceState, UniverseState};

    #[test]
    fn test_escape_luau_string() {
        assert_eq!(escape_luau_string("hello"), "hello");
        assert_eq!(escape_luau_string("hello\"world"), "hello\\\"world");
        assert_eq!(escape_luau_string("line1\nline2"), "line1\\nline2");
    }

    #[test]
    fn test_generate_luau_content() {
        let mut state = SyncState::default();
        state.universe = Some(UniverseState {
            name: Some("Test Game".to_string()),
            description: Some("A test game".to_string()),
            genre: None,
            playable_devices: Some(vec!["computer".to_string(), "phone".to_string()]),
            max_players: Some(50),
            private_server_cost: Some("disabled".to_string()),
        });
        state.game_passes.insert(
            123,
            ResourceState {
                name: "VIP".to_string(),
                description: Some("VIP access".to_string()),
                price: Some(100),
                is_for_sale: Some(true),
                is_enabled: None,
                icon_hash: None,
                icon_asset_id: None,
            },
        );

        let content = generate_luau_content(&state, 12345);
        assert!(content.contains("Id = 12345"));
        assert!(content.contains("Name = \"Test Game\""));
        assert!(content.contains("MaxPlayers = 50"));
        assert!(content.contains("Id = 123"));
        assert!(content.contains("Description = \"VIP access\""));
        assert!(content.contains("IsForSale = true"));
        assert!(content.contains(":: Universe"));
        assert!(content.contains("GamePass"));
    }
}
